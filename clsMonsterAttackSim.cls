VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
  Persistable = 0  'NotPersistable
  DataBindingBehavior = 0  'vbNone
  DataSourceBehavior  = 0  'vbNone
  MTSTransactionMode  = 0  'NotAnMTSObject
END
Attribute VB_Name = "clsMonsterAttackSim"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Attribute VB_Ext_KEY = "SavedWithClassBuilder6" ,"Yes"
Attribute VB_Ext_KEY = "Top_Level" ,"Yes"
Attribute VB_Ext_KEY = "Member0" ,"colMonsterAttacks"
Option Explicit
Option Base 0

Private m_sAtkName(0 To 4) As String
Private m_nAtkType(0 To 4) As Integer
Private m_nAtkSpellType(0 To 4) As Integer
Private m_nAtkEnergy(0 To 4) As Integer
Private m_nAtkMin(0 To 4) As Integer
Private m_nAtkMax(0 To 4) As Integer
Private m_nAtkChance(0 To 4) As Integer
Private m_nAtkSuccess(0 To 4) As Integer
Private m_nAtkHitSpellMin(0 To 4) As Integer
Private m_nAtkHitSpellMax(0 To 4) As Integer
Private m_nAtkHitSpellType(0 To 4) As Integer
Private m_sAtkHitSpellName(0 To 4) As String
Private m_nAtkResist(0 To 4) As Integer
Private m_nAtkMRdmgResist(0 To 4) As Integer
Private m_nAtkDuration(0 To 4) As Integer

Private m_nStatAtkAttempted(0 To 4) As Currency
Private m_nStatAtkHits(0 To 4) As Currency
Private m_nStatAtkDmgResisted(0 To 4) As Currency
Private m_nStatAtkAttemptDodgedOrResisted(0 To 4) As Currency
Private m_nStatAtkTotalDamage(0 To 4) As Currency

Private m_nStatHitSpell_AtkDmgResisted(0 To 4) As Currency
Private m_nStatHitSpell_AtkTotalDamage(0 To 4) As Currency
Private m_nStatBetweenRound_AtkDmgResisted(0 To 4) As Currency
Private m_nStatBetweenRound_AtkTotalDamage(0 To 4) As Currency

Private m_nUserAC As Long
Private m_nUserDR As Long
Private m_nUserDodge As Long
Private m_nUserMR As Long
Private m_nUserAntiMagic As Integer
Private m_bDodgeBeforeAC As Boolean

Private m_nUserRFIR As Long
Private m_nUserRCOL As Long
Private m_nUserRLIT As Long
Private m_nUserRWAT As Long
Private m_nUserRSTO As Long

Private m_nEnergyPerRound As Integer
Private m_nNumberOfRounds As Long
Private m_nTotalAttacks As Currency
Private m_nTotalDamage As Currency
Private m_nTotalDamagePhys As Currency
Private m_nTotalDamageSpell As Currency
Private m_nMaxRoundDamage As Currency
Private m_nAverageDamage As Currency
Private m_nAverageDamagePhys As Currency
Private m_nAverageDamageSpell As Currency
Private m_nMaxEnergyPerRound As Long
Private m_bHideEnergyInfo As Boolean

Private m_bGreaterMUD As Boolean
Private m_bDynamicCalc As Boolean
Private m_nDynamicCalcDifference As Currency
Private m_bUseCPU As Boolean

Private m_cProgressBar As ProgressBar
Private nProgressBarScale As Integer
Private nProgressBarScaleCount As Long

Private m_sCombatLog As String
Private m_nCombatLogMaxRounds As Long
Private nCombatLogRoundCount As Long
Private m_bCombatLogMaxRoundOnly As Boolean

Private m_sBetweenRoundName(0 To 4) As String
Private m_nBetweenRoundMin(0 To 4) As Integer
Private m_nBetweenRoundMax(0 To 4) As Integer
Private m_nBetweenRoundSpellType(0 To 4) As Integer
Private m_nBetweenRoundChance(0 To 4) As Integer
Private m_nBetweenRoundResistType(0 To 4) As Integer
Private m_nBetweenRoundResistDmgMR(0 To 4) As Integer
Private m_nBetweenRoundDuration(0 To 4) As Integer

Private m_HIT_MIN As Integer
Private m_HIT_CAP As Integer
Private m_SPELL_HIT_CAP As Integer
Private m_DODGE_SOFTCAP As Integer
Private m_DODGE_CAP As Integer

Private nActiveAtkSpells_Ticks(0 To 4) As Integer
Private nActiveAtkSpells_DurationLeft(0 To 4) As Currency
Private nActiveAtkSpells_Value(0 To 4) As Integer
Private nActiveAtkSpells_ValueOriginal(0 To 4) As Integer

Private nActiveBetweenSpells_Ticks(0 To 4) As Integer
Private nActiveBetweenSpells_DurationLeft(0 To 4) As Currency
Private nActiveBetweenSpells_Value(0 To 4) As Integer
Private nActiveBetweenSpells_ValueOriginal(0 To 4) As Integer

Public Property Get HIT_MIN() As Integer
    HIT_MIN = m_HIT_MIN
End Property

Public Property Let HIT_MIN(ByVal vData As Integer)
    m_HIT_MIN = vData
End Property

Public Property Get HIT_CAP() As Integer
    HIT_CAP = m_HIT_CAP
End Property

Public Property Let HIT_CAP(ByVal vData As Integer)
    m_HIT_CAP = vData
End Property

Public Property Get SPELL_HIT_CAP() As Integer
    SPELL_HIT_CAP = m_SPELL_HIT_CAP
End Property

Public Property Let SPELL_HIT_CAP(ByVal vData As Integer)
    m_SPELL_HIT_CAP = vData
End Property

Public Property Get DODGE_SOFTCAP() As Integer
    DODGE_SOFTCAP = m_DODGE_SOFTCAP
End Property

Public Property Let DODGE_SOFTCAP(ByVal vData As Integer)
    m_DODGE_SOFTCAP = vData
End Property

Public Property Get DODGE_CAP() As Integer
    DODGE_CAP = m_DODGE_CAP
End Property

Public Property Let DODGE_CAP(ByVal vData As Integer)
    m_DODGE_CAP = vData
End Property

Public Property Let bDodgeBeforeAC(ByVal vData As Boolean)
    m_bDodgeBeforeAC = vData
End Property

Public Property Get bDodgeBeforeAC() As Boolean
    bDodgeBeforeAC = m_bDodgeBeforeAC
End Property

Public Property Let bHideEnergyInfo(ByVal vData As Boolean)
    m_bHideEnergyInfo = vData
End Property

Public Property Get bHideEnergyInfo() As Boolean
    bHideEnergyInfo = m_bHideEnergyInfo
End Property

Public Property Let bCombatLogMaxRoundOnly(ByVal vData As Boolean)
    m_bCombatLogMaxRoundOnly = vData
End Property

Public Property Get bCombatLogMaxRoundOnly() As Boolean
    bCombatLogMaxRoundOnly = m_bCombatLogMaxRoundOnly
End Property

Public Property Get nMaxEnergyPerRound() As Long
    nMaxEnergyPerRound = m_nMaxEnergyPerRound
End Property

Public Property Get nAverageDamage() As Currency
    nAverageDamage = m_nAverageDamage
End Property

Public Property Get nAverageDamagePhys() As Currency
    nAverageDamagePhys = m_nAverageDamagePhys
End Property

Public Property Get nAverageDamageSpell() As Currency
    nAverageDamageSpell = m_nAverageDamageSpell
End Property

Public Property Let bGreaterMUD(ByVal vData As Boolean)
    m_bGreaterMUD = vData
End Property

Public Property Get bGreaterMUD() As Boolean
    bGreaterMUD = m_bGreaterMUD
End Property

Public Property Let nDynamicCalcDifference(ByVal vData As Currency)
    m_nDynamicCalcDifference = vData
End Property

Public Property Get nDynamicCalcDifference() As Currency
    nDynamicCalcDifference = m_nDynamicCalcDifference
End Property

Public Property Let bDynamicCalc(ByVal vData As Boolean)
    m_bDynamicCalc = vData
End Property

Public Property Get bDynamicCalc() As Boolean
    bDynamicCalc = m_bDynamicCalc
End Property

Public Property Get nAtkDuration(ByVal Index As Integer) As Integer
    nAtkDuration = m_nAtkDuration(Index)
End Property

Public Property Let nAtkDuration(ByVal Index As Integer, ByVal iData As Integer)
    m_nAtkDuration(Index) = iData
End Property

Public Property Get nBetweenRoundDuration(ByVal Index As Integer) As Integer
    nBetweenRoundDuration = m_nBetweenRoundDuration(Index)
End Property
Public Property Let nBetweenRoundSpellType(ByVal Index As Integer, ByVal vData As Integer)
    m_nBetweenRoundSpellType(Index) = vData
End Property
Public Property Get nBetweenRoundSpellType(ByVal Index As Integer) As Integer
    nBetweenRoundSpellType = m_nBetweenRoundSpellType(Index)
End Property
Public Property Let nBetweenRoundDuration(ByVal Index As Integer, ByVal iData As Integer)
    m_nBetweenRoundDuration(Index) = iData
End Property

Public Property Get nBetweenRoundResistDmgMR(ByVal Index As Integer) As Integer
    nBetweenRoundResistDmgMR = m_nBetweenRoundResistDmgMR(Index)
End Property

Public Property Let nBetweenRoundResistDmgMR(ByVal Index As Integer, ByVal iData As Integer)
    m_nBetweenRoundResistDmgMR(Index) = iData
End Property

Public Property Get nBetweenRoundResistType(ByVal Index As Integer) As Integer
    nBetweenRoundResistType = m_nBetweenRoundResistType(Index)
End Property

Public Property Let nBetweenRoundResistType(ByVal Index As Integer, ByVal iData As Integer)
    m_nBetweenRoundResistType(Index) = iData
End Property

Public Property Get sBetweenRoundName(ByVal Index As Integer) As String
    sBetweenRoundName = m_sBetweenRoundName(Index)
End Property

Public Property Let sBetweenRoundName(ByVal Index As Integer, ByVal sData As String)
    m_sBetweenRoundName(Index) = sData
End Property

Public Property Get nBetweenRoundMin(ByVal Index As Integer) As Integer
    nBetweenRoundMin = m_nBetweenRoundMin(Index)
End Property

Public Property Get nBetweenRoundMax(ByVal Index As Integer) As Integer
    nBetweenRoundMax = m_nBetweenRoundMax(Index)
End Property

Public Property Get nBetweenRoundChance(ByVal Index As Integer) As Integer
    nBetweenRoundChance = m_nBetweenRoundChance(Index)
End Property

Public Property Let nBetweenRoundChance(ByVal Index As Integer, ByVal iData As Integer)
    m_nBetweenRoundChance(Index) = iData
End Property

Public Property Let nBetweenRoundMax(ByVal Index As Integer, ByVal iData As Integer)
    m_nBetweenRoundMax(Index) = iData
End Property

Public Property Let nBetweenRoundMin(ByVal Index As Integer, ByVal iData As Integer)
    m_nBetweenRoundMin(Index) = iData
End Property

Public Property Get nMaxRoundDamage() As Long
    nMaxRoundDamage = m_nMaxRoundDamage
End Property

Public Property Get nCombatLogMaxRounds() As Long
    nCombatLogMaxRounds = m_nCombatLogMaxRounds
End Property

Public Property Let nCombatLogMaxRounds(ByVal lNewValue As Long)
    m_nCombatLogMaxRounds = lNewValue
End Property

Public Property Get sCombatLog() As String
    sCombatLog = m_sCombatLog
End Property

Public Property Get nTotalDamage() As Currency
    nTotalDamage = m_nTotalDamage
End Property

Public Property Get nTotalAttacks() As Long
    nTotalAttacks = m_nTotalAttacks
End Property

Public Property Let bUseCPU(ByVal vData As Boolean)
    m_bUseCPU = vData
End Property

Public Property Get bUseCPU() As Boolean
    bUseCPU = m_bUseCPU
End Property

Public Function RandomNumber(startNum As Integer, endNum As Integer) As Integer
    RandomNumber = Int(((endNum - startNum + 1) * Rnd) + startNum)
End Function

Private Sub AddToCombatLog(sLeft As String, Optional sRight As String = "")
On Error GoTo error:

If nCombatLogRoundCount >= m_nCombatLogMaxRounds Then Exit Sub

If m_bHideEnergyInfo Then
    If InStr(1, sRight, "Energy", vbTextCompare) > 0 Then sRight = ""
End If

If Len(sRight) > 0 And Len(sLeft) > 29 Then
    sLeft = mid(sLeft, 1, 26) & "..."
End If
m_sCombatLog = m_sCombatLog & vbCrLf & sLeft
If Len(sRight) > 0 Then m_sCombatLog = m_sCombatLog & String(30 - Len(sLeft), " ") & sRight

out:
On Error Resume Next
Exit Sub
error:
Call privHandleError("AddToCombatLog")
Resume out:
End Sub

Public Function GetMaxDamage()
Dim x As Integer, bNothingToSim As Boolean
Dim nAttack As Integer
Dim nLeastEnergyUsed As Long, nLowestCostAttack As Long, nLowEnergy As Long
Dim nMaxEnergyRound As Long, nMaxCostAttack As Long
Dim nDamage As Long, nMaxDamage As Long, nMaxAttempts As Integer, nMaxDPE As Currency
Dim nEnergyForAttack As Long, nEnergyRemaining As Long, nDamagePerEnergy As Currency
On Error GoTo error:

GetMaxDamage = 0

bNothingToSim = True: x = 0
Do While x <= 4 And bNothingToSim
    If m_nAtkMin(x) > 0 Then bNothingToSim = False
    If m_nAtkMax(x) > 0 Then bNothingToSim = False
    If m_nAtkHitSpellMin(x) > 0 Then bNothingToSim = False
    If m_nAtkHitSpellMax(x) > 0 Then bNothingToSim = False
    If m_nBetweenRoundMin(x) > 0 Then bNothingToSim = False
    If m_nBetweenRoundMax(x) > 0 Then bNothingToSim = False
    x = x + 1
Loop
If bNothingToSim Then GoTo out:

'determin lowest cost attack and highest cost attack
For nAttack = 0 To 4
    If m_nAtkType(nAttack) > 0 And m_nAtkEnergy(nAttack) > 0 Then
        nLowEnergy = m_nAtkEnergy(nAttack)
        If m_nAtkType(nAttack) = 2 Then 'spell
            If ((m_nAtkResist(nAttack) = 1 And m_nUserAntiMagic = 1) Or m_nAtkResist(nAttack) = 2) _
                Or m_nAtkSuccess(nAttack) < 100 Then 'resistable or failable
                
                nLowEnergy = Round(m_nAtkEnergy(nAttack) / 2)
            End If
        End If
        
        If (nLowestCostAttack = 0 Or nLowEnergy < nLowestCostAttack) And nLowEnergy > 0 Then
            nLowestCostAttack = nLowEnergy
        End If
        
        If nMaxCostAttack = 0 Or m_nAtkEnergy(nAttack) > nMaxCostAttack Then
            nMaxCostAttack = m_nAtkEnergy(nAttack)
        End If
    ElseIf m_nAtkType(nAttack) > 0 And m_nAtkEnergy(nAttack) = 0 And m_nAtkChance(nAttack) > 0 Then
        nLowestCostAttack = 0
        nMaxEnergyRound = m_nEnergyPerRound * 2
        GoTo zero_energy_attack_skip_calc:
    End If
Next nAttack
If nLowestCostAttack = 0 Then GoTo out:

'determine max energy / round
nMaxEnergyRound = m_nEnergyPerRound

nLeastEnergyUsed = nLowestCostAttack
Do While (nLeastEnergyUsed + nMaxCostAttack) <= nMaxEnergyRound
    nLeastEnergyUsed = nLeastEnergyUsed + nLowestCostAttack
Loop
nEnergyRemaining = (m_nEnergyPerRound - nLeastEnergyUsed)
If nEnergyRemaining < nLowestCostAttack Then nEnergyRemaining = nEnergyRemaining + (nLowestCostAttack - 1)

nMaxEnergyRound = m_nEnergyPerRound + nEnergyRemaining

zero_energy_attack_skip_calc:
'determine max damage from regular attacks
nEnergyRemaining = nMaxEnergyRound
x = 1
Do While nEnergyRemaining >= nLowestCostAttack And x <= 6
    nDamage = 0: nMaxDamage = 0: nEnergyForAttack = 0: nMaxDPE = 0
    
    For nAttack = 0 To 4
        If m_nAtkEnergy(nAttack) <= nEnergyRemaining And m_nAtkEnergy(nAttack) > 0 Then
            If (m_nAtkType(nAttack) <> 2 Or m_nAtkSuccess(nAttack) > 0) And m_nAtkType(nAttack) > 0 Then
                nDamage = m_nAtkMax(nAttack)
                If m_nAtkType(nAttack) = 1 Then
                    If Not m_nAtkDuration(nAttack) > 1 Then
                        nDamage = nDamage + m_nAtkHitSpellMax(nAttack)
                    End If
                End If
                
                nMaxAttempts = Fix(nEnergyRemaining / m_nAtkEnergy(nAttack))
                If nMaxAttempts > (6 - x + 1) Then nMaxAttempts = (6 - x + 1)
                
                nDamagePerEnergy = (nDamage * nMaxAttempts) / nEnergyRemaining
                If nDamagePerEnergy > nMaxDPE Then
                    nMaxDamage = nDamage
                    nMaxDPE = nDamagePerEnergy
                    nEnergyForAttack = m_nAtkEnergy(nAttack)
                End If
            End If
        End If
    Next nAttack
    
    GetMaxDamage = GetMaxDamage + nMaxDamage
    nEnergyRemaining = nEnergyRemaining - nEnergyForAttack
    x = x + 1
Loop
'add spell/hitspell duration ticks
For nAttack = 0 To 4
    If m_nAtkType(nAttack) = 1 And m_nAtkDuration(nAttack) > 1 Then
        GetMaxDamage = GetMaxDamage + m_nAtkHitSpellMax(nAttack)
        If m_nAtkDuration(nAttack) > 2 Then GetMaxDamage = GetMaxDamage + m_nAtkHitSpellMax(nAttack)
    ElseIf m_nAtkType(nAttack) = 2 And m_nAtkDuration(nAttack) > 1 Then
        GetMaxDamage = GetMaxDamage + m_nAtkMax(nAttack)
        If m_nAtkDuration(nAttack) > 2 Then GetMaxDamage = GetMaxDamage + m_nAtkMax(nAttack)
    End If
Next nAttack

'between rounds
nMaxDamage = 0
For x = 0 To 4
    If m_nBetweenRoundChance(x) > 0 And Not m_nBetweenRoundDuration(x) > 1 Then
        nDamage = m_nBetweenRoundMax(x)
        If nDamage > nMaxDamage Then nMaxDamage = nDamage
    End If
Next x
GetMaxDamage = GetMaxDamage + nMaxDamage
'add between round duration ticks
For x = 0 To 4
    If m_nBetweenRoundChance(x) > 0 And m_nBetweenRoundDuration(x) > 1 Then
        GetMaxDamage = GetMaxDamage + m_nBetweenRoundMax(x)
        If m_nBetweenRoundDuration(x) > 2 Then GetMaxDamage = GetMaxDamage + m_nBetweenRoundMax(x)
    End If
Next x

out:
On Error Resume Next
Exit Function
error:
Call HandleError("GetMaxDamage")
Resume out:
End Function

Public Sub RunSim()
On Error GoTo error:
Dim nRound As Long, nAttempt As Integer, nAttack As Integer, x As Integer
Dim nRemainingEnergy As Long, nEnergyUsed As Integer, bShowHitSpell As Boolean
Dim nDR_DamageResisted As Currency, nMR_Reduction As Currency, nResist_Reduction As Currency
Dim bAttackHit As Boolean, bDodged As Boolean, bGlanced As Boolean, bResisted As Boolean
Dim nLastAttackType As Integer, nLastAttackEnergy As Integer, nAttack_AdjSuccessChance As Currency
Dim nRoll_AttackChance As Integer, nRoll_HitChance As Integer, nRoll_DodgeChance As Integer, nAdjustedDodgeValue As Long
Dim nDamage As Currency, nHitSpellDamage As Currency, nRoundDamage As Long, nOriginalDamage As Currency
Dim bSepShown As Boolean, bDurSpellApplied As Boolean, bNothingToSim As Boolean
Dim nCurrentAverageDamage As Currency, nDifference As Currency, nDynamicRoundCount As Long
Dim sMaxRoundCombatLog As String, sHitSpellName As String, nAccTemp As Double

Randomize
If m_bDynamicCalc Then m_nNumberOfRounds = 100000

If m_nNumberOfRounds < 1 Then Exit Sub
If m_nEnergyPerRound < 1 Then Exit Sub

m_nTotalAttacks = 0
m_nTotalDamage = 0
m_nTotalDamagePhys = 0
m_nTotalDamageSpell = 0
m_nMaxRoundDamage = 0
m_nMaxEnergyPerRound = 0

If m_HIT_MIN < 0 Then m_HIT_MIN = 0: If m_HIT_MIN > 100 Then m_HIT_MIN = 100
If m_HIT_CAP < 0 Then m_HIT_CAP = 0: If m_HIT_CAP > 100 Then m_HIT_CAP = 100
If m_SPELL_HIT_CAP < 0 Then m_SPELL_HIT_CAP = 0: If m_SPELL_HIT_CAP > 100 Then m_SPELL_HIT_CAP = 100
If m_DODGE_SOFTCAP < 0 Then m_DODGE_SOFTCAP = 0: If m_DODGE_SOFTCAP > 100 Then m_DODGE_SOFTCAP = 100
If m_DODGE_CAP < 0 Then m_DODGE_CAP = 0: If m_DODGE_CAP > 100 Then m_DODGE_CAP = 100

Call ResetActiveSpells

bNothingToSim = True: x = 0
Do While x <= 4 And bNothingToSim
    If m_nAtkMin(x) > 0 Then bNothingToSim = False
    If m_nAtkMax(x) > 0 Then bNothingToSim = False
    If m_nAtkHitSpellMin(x) > 0 Then bNothingToSim = False
    If m_nAtkHitSpellMax(x) > 0 Then bNothingToSim = False
    If m_nBetweenRoundMin(x) > 0 Then bNothingToSim = False
    If m_nBetweenRoundMax(x) > 0 Then bNothingToSim = False
    x = x + 1
Loop
If bNothingToSim Then GoTo end_sim:

Call ProgressBarSetRange(m_nNumberOfRounds)

m_sCombatLog = "=================================================================="
nCombatLogRoundCount = 0
If m_nCombatLogMaxRounds < 0 Then m_nCombatLogMaxRounds = 0

nRemainingEnergy = 0
For nRound = 1 To m_nNumberOfRounds
    
    nRoundDamage = 0
    bSepShown = False
    
    '============================================================================
    ' CHECK FOR EXTRA SPELL ROUND TICKS
    ' (SPELL ROUND = 3s, COMBAT ROUND 5s ... EVERY 3 ROUNDS = EXTRA SPELL ROUND)
    '============================================================================
    For x = 0 To 4
    
        '============================================================================
        ' regular attack spell duration and hit spell duration
        '============================================================================
        If nActiveAtkSpells_DurationLeft(x) > 0 Then
            If nActiveAtkSpells_Ticks(x) = 3 Then '15 seconds has based, second tick goes off
                
                nRoundDamage = nRoundDamage + nActiveAtkSpells_Value(x)
                m_nTotalDamage = m_nTotalDamage + nActiveAtkSpells_Value(x)
                m_nTotalDamageSpell = m_nTotalDamageSpell + nActiveAtkSpells_Value(x)
                m_nStatAtkTotalDamage(x) = m_nStatAtkTotalDamage(x) + nActiveAtkSpells_Value(x)
                m_nStatAtkDmgResisted(x) = m_nStatAtkDmgResisted(x) + (nActiveAtkSpells_ValueOriginal(x) - nActiveAtkSpells_Value(x))
                
                'added 2025.06.05
                m_nStatHitSpell_AtkDmgResisted(x) = m_nStatHitSpell_AtkDmgResisted(x) + (nActiveAtkSpells_ValueOriginal(x) - nActiveAtkSpells_Value(x))
                m_nStatHitSpell_AtkTotalDamage(x) = m_nStatHitSpell_AtkTotalDamage(x) + nActiveAtkSpells_Value(x)
                
                If Not bSepShown Then
                    Call AddToCombatLog("")
                    bSepShown = True
                End If
                
                nActiveAtkSpells_DurationLeft(x) = nActiveAtkSpells_DurationLeft(x) - 1
                
                If m_nAtkType(x) = 2 Then 'spell
                    Call AddToCombatLog("[" & m_sAtkName(x) & ", spell tick] for " & nActiveAtkSpells_Value(x) _
                        & " -- " & nActiveAtkSpells_DurationLeft(x) & " rounds rem.")
                Else
                    sHitSpellName = IIf(Len(m_sAtkHitSpellName(x)) = 0, "attack " & (x + 1), m_sAtkHitSpellName(x))
                    Call AddToCombatLog("[" & sHitSpellName & ", hit spell tick] for " & nActiveAtkSpells_Value(x) _
                        & " -- " & nActiveAtkSpells_DurationLeft(x) & " rounds rem.")
                End If
                
                If nActiveAtkSpells_DurationLeft(x) < 1 Then Call ResetActiveAtkSpell(x)
            End If
        End If
        
        '============================================================================
        ' between round spell durations
        '============================================================================
        If nActiveBetweenSpells_DurationLeft(x) > 0 Then
            If nActiveBetweenSpells_Ticks(x) = 3 Then '15 seconds has passed, second tick goes off
                
                nRoundDamage = nRoundDamage + nActiveBetweenSpells_Value(x)
                m_nTotalDamage = m_nTotalDamage + nActiveBetweenSpells_Value(x)
                m_nTotalDamageSpell = m_nTotalDamageSpell + nActiveBetweenSpells_Value(x)
                 
                'added 2025.06.05
                m_nStatBetweenRound_AtkDmgResisted(x) = m_nStatBetweenRound_AtkDmgResisted(x) + (nActiveBetweenSpells_ValueOriginal(x) - nActiveBetweenSpells_Value(x))
                m_nStatBetweenRound_AtkTotalDamage(x) = m_nStatBetweenRound_AtkTotalDamage(x) + nActiveBetweenSpells_Value(x)
                
                If Not bSepShown Then
                    Call AddToCombatLog("")
                    bSepShown = True
                End If
                
                nActiveBetweenSpells_DurationLeft(x) = nActiveBetweenSpells_DurationLeft(x) - 1
                
                Call AddToCombatLog("[" & m_sBetweenRoundName(x) & ", between spell tick] for " & nActiveBetweenSpells_Value(x) _
                    & " -- " & nActiveBetweenSpells_DurationLeft(x) & " rounds rem.")
                
                If nActiveBetweenSpells_DurationLeft(x) < 1 Then Call ResetActiveBetweenSpell(x)
            End If
        End If
    Next x
    
    If bSepShown Then
        Call AddToCombatLog("")
        bSepShown = False
    End If
    
    If m_bHideEnergyInfo Then
        Call AddToCombatLog("ROUND " & nRound)
    Else
        Call AddToCombatLog("ROUND " & nRound & " / Energy: " _
            & nRemainingEnergy & " + " & m_nEnergyPerRound & " = " & (nRemainingEnergy + m_nEnergyPerRound))
    End If
    Call AddToCombatLog("")
    
    nRemainingEnergy = nRemainingEnergy + m_nEnergyPerRound
    If nRemainingEnergy > m_nMaxEnergyPerRound Then m_nMaxEnergyPerRound = nRemainingEnergy
    
    '============================================================================
    ' BEGIN REGULAR ATTACK ATTEMPTS
    '============================================================================
    For nAttempt = 1 To 6
        nRoll_AttackChance = Me.RandomNumber(1, 100)
        nLastAttackType = 0
        nLastAttackEnergy = 0
        
        For nAttack = 0 To 4
        
            nDamage = 0: nHitSpellDamage = 0: nOriginalDamage = 0: nMR_Reduction = 0
            bShowHitSpell = False: bDurSpellApplied = False
            If nRoll_AttackChance <= m_nAtkChance(nAttack) And m_nAtkType(nAttack) > 0 Then
                
                nLastAttackEnergy = m_nAtkEnergy(nAttack)
                nLastAttackType = m_nAtkType(nAttack)
                
                If nRemainingEnergy < m_nAtkEnergy(nAttack) Then
                    'no energy for attack
                Else
                    m_nStatAtkAttempted(nAttack) = m_nStatAtkAttempted(nAttack) + 1
                    m_nTotalAttacks = m_nTotalAttacks + 1
                    
                    bAttackHit = False: bDodged = False: bGlanced = False: bResisted = False
                    
                    ' CHANCE TO HIT / CAST
                    nAttack_AdjSuccessChance = m_nAtkSuccess(nAttack)
                    If m_nAtkType(nAttack) <> 2 Then 'not spell
                        If m_nUserAC > 0 Then
                            '=((AC*AC)/100)/((ACCY*ACCY)/140)=fail %
                            If nAttack_AdjSuccessChance <> 0 Then
                                nAttack_AdjSuccessChance = Round(1 - (((m_nUserAC * m_nUserAC) / 100) / ((nAttack_AdjSuccessChance * nAttack_AdjSuccessChance) / 140)), 2) * 100
                            Else
                                nAttack_AdjSuccessChance = 0
                            End If
                        Else
                            nAttack_AdjSuccessChance = m_HIT_CAP
                        End If
                        
                        'PHYSICAL ATTACKS = 9% MIN HIT CHANCE, 99% MAX (stock)
                        If nAttack_AdjSuccessChance < m_HIT_MIN Then nAttack_AdjSuccessChance = m_HIT_MIN
                        If nAttack_AdjSuccessChance > m_HIT_CAP Then nAttack_AdjSuccessChance = m_HIT_CAP
                        
                    End If
                    
                    'this will allow the dodge percentage to match what players see in megamud
                    If m_bDodgeBeforeAC And m_nUserDodge > 0 And m_nAtkType(nAttack) <> 2 Then
                        nRoll_DodgeChance = Me.RandomNumber(1, 100)
                        If nRoll_DodgeChance <= m_nUserDodge Then
                            bAttackHit = False: bDodged = True
                            m_nStatAtkAttemptDodgedOrResisted(nAttack) = m_nStatAtkAttemptDodgedOrResisted(nAttack) + 1
                        End If
                    End If
                    
                    If m_bDodgeBeforeAC = False Or bDodged = False Then
                        nRoll_HitChance = Me.RandomNumber(1, 100)
                        If nRoll_HitChance <= nAttack_AdjSuccessChance Then
                            bAttackHit = True
                            If m_nAtkType(nAttack) <> 2 And m_nUserDodge > 0 And m_bDodgeBeforeAC = False And m_nAtkSuccess(nAttack) >= 8 Then
                                
                                If bGreaterMUD Then
                                    nAccTemp = m_nAtkSuccess(nAttack)
                                    nAccTemp = (((nAccTemp * nAccTemp) / 14) / 10)
                                    nAdjustedDodgeValue = (m_nUserDodge * m_nUserDodge) / nAccTemp
                                    'IF GMUD EVER DOES DIFFERENT DODGE CAPS FOR DIFFERENT CLASSES AGAIN, THAT NEEDS TO BE IMPLEMENDED HERE [i.e. nSoftCap = GetDodgeCap(nClass, True)]
                                    If nAdjustedDodgeValue > m_DODGE_SOFTCAP And m_DODGE_SOFTCAP > 0 Then
                                        nAdjustedDodgeValue = m_DODGE_SOFTCAP + Apply_GMUD_DiminishingReturns(nAdjustedDodgeValue - m_DODGE_SOFTCAP, 4#)
                                    End If
                                    
                                Else
                                    nAdjustedDodgeValue = Fix((m_nUserDodge * 10) / (m_nAtkSuccess(nAttack) / 8))
                                    
                                End If
                                If nAdjustedDodgeValue > m_DODGE_CAP Then nAdjustedDodgeValue = m_DODGE_CAP
                                
                                nRoll_DodgeChance = Me.RandomNumber(1, 100)
                                If nRoll_DodgeChance <= nAdjustedDodgeValue Then
                                    bAttackHit = False: bDodged = True
                                    m_nStatAtkAttemptDodgedOrResisted(nAttack) = m_nStatAtkAttemptDodgedOrResisted(nAttack) + 1
                                End If
                                
                            End If
                        End If
                    End If
                    
                    If bAttackHit Then
                    
                        nDamage = Me.RandomNumber(m_nAtkMin(nAttack), m_nAtkMax(nAttack))
                        nOriginalDamage = nDamage
                        
                        '============================================================================
                        ' SPELL ATTACK ?
                        '============================================================================
                        If m_nAtkType(nAttack) = 2 Then 'spell
                            
                            nActiveAtkSpells_ValueOriginal(nAttack) = nDamage
                            
                            If m_nAtkMRdmgResist(nAttack) = 1 And nDamage > 0 Then
                                nMR_Reduction = Round(CalcResistedDamage(nDamage, m_nUserMR, m_nUserAntiMagic))
                                'If m_nAtkDuration(nAttack) = 0 Then
                                '    m_nStatAtkDmgResisted(nAttack) = m_nStatAtkDmgResisted(nAttack) + (nDamage - nMR_Reduction)
                                'End If
                                nDamage = nMR_Reduction
                            End If
                            
                            If m_nAtkSpellType(nAttack) <> 4 And m_nAtkSpellType(nAttack) <> 6 Then 'normal-4 & poison-6
                                Select Case m_nAtkSpellType(nAttack)
                                    Case 0: If m_nUserRCOL > 0 Then nResist_Reduction = (nDamage * (m_nUserRCOL / 100))  'col
                                    Case 1: If m_nUserRFIR > 0 Then nResist_Reduction = (nDamage * (m_nUserRFIR / 100))  'fir
                                    Case 2: If m_nUserRSTO > 0 Then nResist_Reduction = (nDamage * (m_nUserRSTO / 100))  'sto
                                    Case 3: If m_nUserRLIT > 0 Then nResist_Reduction = (nDamage * (m_nUserRLIT / 100))  'lit
                                    Case 5: If m_nUserRWAT > 0 Then nResist_Reduction = (nDamage * (m_nUserRWAT / 100))  'wat
                                End Select
                                If nResist_Reduction <> 0 Then nDamage = Round(nDamage - nResist_Reduction)
                            End If
                            
                            If m_nAtkDuration(nAttack) > 0 Then
                                If nActiveAtkSpells_DurationLeft(nAttack) < 1 Or nActiveAtkSpells_Value(nAttack) <> nDamage Then
                                    
                                    If IsSpellResisted(m_nAtkResist(nAttack), m_nUserMR, m_nUserAntiMagic) Then
                                                                    
                                        m_nStatAtkAttemptDodgedOrResisted(nAttack) = m_nStatAtkAttemptDodgedOrResisted(nAttack) + 1
                                        bResisted = True
                                        bAttackHit = False
                                        nDamage = 0
                                        
                                    Else
                                    
                                        Call ResetActiveAtkSpell(nAttack)
                                        nActiveAtkSpells_DurationLeft(nAttack) = m_nAtkDuration(nAttack)
                                        nActiveAtkSpells_Value(nAttack) = nDamage
                                        bDurSpellApplied = True
                                        nDamage = 0
                                    
                                    End If
                                Else
                                    'DURATION CONTINUES, NOT REALLY AN ATTEMPT
                                    m_nStatAtkAttempted(nAttack) = m_nStatAtkAttempted(nAttack) - 1
                                    m_nTotalAttacks = m_nTotalAttacks - 1
                                    GoTo choose_next_attack:
                                End If
                            Else
                                If IsSpellResisted(m_nAtkResist(nAttack), m_nUserMR, m_nUserAntiMagic) Then
                                                                    
                                    m_nStatAtkAttemptDodgedOrResisted(nAttack) = m_nStatAtkAttemptDodgedOrResisted(nAttack) + 1
                                    'm_nStatAtkDmgResisted(nAttack) = m_nStatAtkDmgResisted(nAttack) + nDamage
                                    bResisted = True
                                    bAttackHit = False
                                    nDamage = 0
                                  
                                End If
                                
                            End If
                            
                        '============================================================================
                        ' NORMAL ATTACK
                        '============================================================================
                        Else
                            'normal/rob
                            nDR_DamageResisted = m_nUserDR '(m_nUserDR / 2)
                            If nDR_DamageResisted > nDamage Then nDR_DamageResisted = nDamage
                            m_nStatAtkDmgResisted(nAttack) = m_nStatAtkDmgResisted(nAttack) + nDR_DamageResisted
                            nDamage = nDamage - nDR_DamageResisted
                            
                            '============================================================================
                            ' HIT SPELL APPLICATION CHECK
                            '============================================================================
                            If m_nAtkHitSpellMin(nAttack) > 0 Or m_nAtkHitSpellMax(nAttack) > 0 Or m_nAtkDuration(nAttack) > 0 Then
                                
                                nHitSpellDamage = Round(Me.RandomNumber(m_nAtkHitSpellMin(nAttack), m_nAtkHitSpellMax(nAttack)))
                                nActiveAtkSpells_ValueOriginal(nAttack) = nHitSpellDamage
                                
                                If m_nAtkMRdmgResist(nAttack) = 1 And nHitSpellDamage > 0 Then
                                    nMR_Reduction = Round(CalcResistedDamage(nHitSpellDamage, m_nUserMR, m_nUserAntiMagic))
                                    If m_nAtkDuration(nAttack) = 0 Then
                                        m_nStatAtkDmgResisted(nAttack) = m_nStatAtkDmgResisted(nAttack) + (nHitSpellDamage - nMR_Reduction)
                                    End If
                                    nHitSpellDamage = nMR_Reduction
                                End If
                                
                                If m_nAtkHitSpellType(nAttack) <> 4 And m_nAtkHitSpellType(nAttack) <> 6 Then 'normal-4 & poison-6
                                    Select Case m_nAtkHitSpellType(nAttack)
                                        Case 0: If m_nUserRCOL > 0 Then nResist_Reduction = (nHitSpellDamage * (m_nUserRCOL / 100))  'col
                                        Case 1: If m_nUserRFIR > 0 Then nResist_Reduction = (nHitSpellDamage * (m_nUserRFIR / 100))  'fir
                                        Case 2: If m_nUserRSTO > 0 Then nResist_Reduction = (nHitSpellDamage * (m_nUserRSTO / 100))  'sto
                                        Case 3: If m_nUserRLIT > 0 Then nResist_Reduction = (nHitSpellDamage * (m_nUserRLIT / 100))  'lit
                                        Case 5: If m_nUserRWAT > 0 Then nResist_Reduction = (nHitSpellDamage * (m_nUserRWAT / 100))  'wat
                                    End Select
                                    If nResist_Reduction <> 0 Then
                                        If m_nAtkDuration(nAttack) = 0 Then
                                            m_nStatAtkDmgResisted(nAttack) = Round(m_nStatAtkDmgResisted(nAttack) + nResist_Reduction)
                                        End If
                                        nHitSpellDamage = Round(nHitSpellDamage - nResist_Reduction)
                                    End If
                                End If
                                
                                If m_nAtkDuration(nAttack) > 0 Then
                                    If nActiveAtkSpells_DurationLeft(nAttack) < 1 Or nActiveAtkSpells_Value(nAttack) <> nHitSpellDamage Then
                                        
                                        If IsSpellResisted(m_nAtkResist(nAttack), m_nUserMR, m_nUserAntiMagic) Then
                                                                        
                                            m_nStatAtkDmgResisted(nAttack) = m_nStatAtkDmgResisted(nAttack) + nHitSpellDamage
                                            bShowHitSpell = True
                                            bResisted = True
                                            nHitSpellDamage = 0
                                            
                                        Else
                                        
                                            Call ResetActiveAtkSpell(nAttack)
                                            nActiveAtkSpells_DurationLeft(nAttack) = m_nAtkDuration(nAttack)
                                            nActiveAtkSpells_Value(nAttack) = nHitSpellDamage
                                            bDurSpellApplied = True
                                            bShowHitSpell = True
                                            nHitSpellDamage = 0
                                        
                                        End If
                                    End If
                                Else
                                    If IsSpellResisted(m_nAtkResist(nAttack), m_nUserMR, m_nUserAntiMagic) Then
                                                                        
                                        m_nStatAtkDmgResisted(nAttack) = m_nStatAtkDmgResisted(nAttack) + nHitSpellDamage
                                        bResisted = True
                                        nHitSpellDamage = 0
                                      
                                    End If
                                    
                                    bShowHitSpell = True
                                End If
                                                                    
                                
                                If Not bShowHitSpell Then nHitSpellDamage = 0
                            End If
                        End If
                        
                        If nDamage <= 0 Then
                            If m_nAtkType(nAttack) <> 2 Then bGlanced = True
                            nDamage = 0
                        End If
                        
                        If bAttackHit Then
                        
                            If nOriginalDamage <> nDamage And m_nAtkType(nAttack) = 2 And m_nAtkDuration(nAttack) < 1 Then 'spell
                                m_nStatAtkDmgResisted(nAttack) = m_nStatAtkDmgResisted(nAttack) + (nOriginalDamage - nDamage)
                            End If
                            
                            nRoundDamage = nRoundDamage + nDamage + nHitSpellDamage
                            m_nTotalDamage = m_nTotalDamage + nDamage + nHitSpellDamage
                            m_nTotalDamageSpell = m_nTotalDamageSpell + nHitSpellDamage
                            If m_nAtkType(nAttack) = 2 Then 'spell
                                m_nTotalDamageSpell = m_nTotalDamageSpell + nDamage
                            Else
                                m_nTotalDamagePhys = m_nTotalDamagePhys + nDamage
                            End If
                            
                            nRemainingEnergy = nRemainingEnergy - m_nAtkEnergy(nAttack)
                            
                            m_nStatAtkHits(nAttack) = m_nStatAtkHits(nAttack) + 1
                            m_nStatAtkTotalDamage(nAttack) = m_nStatAtkTotalDamage(nAttack) + nDamage + nHitSpellDamage
                            
                            If m_nAtkType(nAttack) = 2 And m_nAtkDuration(nAttack) > 0 Then 'duration spell
                                Call AddToCombatLog(m_sAtkName(nAttack) & " applied (" & nActiveAtkSpells_ValueOriginal(nAttack) & ")", _
                                    "Energy used: " & m_nAtkEnergy(nAttack) & " ... Remaining: " & nRemainingEnergy)
                            Else
                                Call AddToCombatLog(m_sAtkName(nAttack) & " for " & Round(nDamage) _
                                    & IIf(bGlanced, " (GLANCE)", ""), _
                                    "Energy used: " & m_nAtkEnergy(nAttack) & " ... Remaining: " & nRemainingEnergy)
                            End If
                            
                            If bShowHitSpell Then
                                If bDurSpellApplied Then
                                    Call AddToCombatLog(" - duration spell applied (" & nActiveAtkSpells_Value(nAttack) & ")")
                                Else
                                    sHitSpellName = IIf(Len(m_sAtkHitSpellName(nAttack)) = 0, "attack " & (x + 1), m_sAtkHitSpellName(nAttack))
                                    Call AddToCombatLog(" -" & sHitSpellName & " " & IIf(bResisted, "(resist)", "for " & Round(nHitSpellDamage)))
                                End If
                            End If
                        End If
                    End If
                    
                    If Not bAttackHit Then
                        If m_nAtkType(nAttack) = 2 Then 'spell
                            'If m_nAtkDuration(nAttack) = 0 Or nActiveAtkSpells_DurationLeft(nAttack) < 1 Then
                            'If m_nAtkDuration(nAttack) = 0 Or bResisted Then
                            If m_nAtkDuration(nAttack) = 0 Or bResisted Then
                                nEnergyUsed = Round(m_nAtkEnergy(nAttack) / 2, 0)
                            
                                nRemainingEnergy = nRemainingEnergy - nEnergyUsed
                                
                                Call AddToCombatLog(m_sAtkName(nAttack) & " (" _
                                    & IIf(bResisted, "RESIST", "FAIL") & ")", _
                                    "Energy used: " & nEnergyUsed & " ... Remaining: " & nRemainingEnergy)
                            End If
                        Else
                            nRemainingEnergy = nRemainingEnergy - m_nAtkEnergy(nAttack)
                            
                            Call AddToCombatLog(m_sAtkName(nAttack) & " (" _
                                & IIf(bDodged, "DODGE", "MISS") & ")", _
                                "Energy used: " & m_nAtkEnergy(nAttack) & " ... Remaining: " & nRemainingEnergy)
                        End If
                    End If
                End If
                
                GoTo next_attempt:
            End If
choose_next_attack:
        Next nAttack
        
next_attempt:
        If nLastAttackType = 1 Then 'spell
            If nRemainingEnergy < nLastAttackEnergy Then GoTo next_round:
        End If

    Next nAttempt
    
next_round:

    '============================================================================
    ' BETWEEN ROUND SPELL CAST
    '============================================================================
    bSepShown = False
    nRoll_AttackChance = Me.RandomNumber(1, 100)
    For x = 0 To 4
        bAttackHit = False: bResisted = False: bDurSpellApplied = False
        
        If m_nBetweenRoundChance(x) > 0 Then
            If nRoll_AttackChance <= m_nBetweenRoundChance(x) Then
            
                nDamage = Me.RandomNumber(m_nBetweenRoundMin(x), m_nBetweenRoundMax(x))
                nActiveBetweenSpells_ValueOriginal(x) = nDamage
                            
                If m_nBetweenRoundResistDmgMR(x) = 1 And nDamage > 0 Then
                    nMR_Reduction = Round(CalcResistedDamage(nDamage, m_nUserMR, m_nUserAntiMagic))
                    nDamage = nMR_Reduction
                End If
                
                If m_nBetweenRoundSpellType(x) <> 4 And m_nBetweenRoundSpellType(x) <> 6 Then 'normal-4 & poison-6
                    Select Case m_nBetweenRoundSpellType(x)
                        Case 0: If m_nUserRCOL > 0 Then nResist_Reduction = (nDamage * (m_nUserRCOL / 100))  'col
                        Case 1: If m_nUserRFIR > 0 Then nResist_Reduction = (nDamage * (m_nUserRFIR / 100))  'fir
                        Case 2: If m_nUserRSTO > 0 Then nResist_Reduction = (nDamage * (m_nUserRSTO / 100))  'sto
                        Case 3: If m_nUserRLIT > 0 Then nResist_Reduction = (nDamage * (m_nUserRLIT / 100))  'lit
                        Case 5: If m_nUserRWAT > 0 Then nResist_Reduction = (nDamage * (m_nUserRWAT / 100))  'wat
                    End Select
                    If nResist_Reduction <> 0 Then nDamage = Round(nDamage - nResist_Reduction)
                End If
                
                If m_nBetweenRoundDuration(x) > 0 Then
                    If nActiveBetweenSpells_DurationLeft(x) < 1 Or nActiveBetweenSpells_Value(x) <> nDamage Then
                        
                        If IsSpellResisted(m_nBetweenRoundResistType(x), m_nUserMR, m_nUserAntiMagic) Then
                            bResisted = True
                            nDamage = 0
                        Else
                            Call ResetActiveBetweenSpell(x)
                            nActiveBetweenSpells_DurationLeft(x) = m_nBetweenRoundDuration(x)
                            nActiveBetweenSpells_Value(x) = nDamage
                            bDurSpellApplied = True
                            nDamage = 0
                        End If
                    End If
                Else
                    If IsSpellResisted(m_nBetweenRoundResistType(x), m_nUserMR, m_nUserAntiMagic) Then
                        bResisted = True
                        nDamage = 0
                    Else
                        bAttackHit = True
                    End If
                End If
            End If
        End If
        
        If Not bSepShown And (bDurSpellApplied Or bResisted Or bAttackHit) Then
            Call AddToCombatLog("")
            bSepShown = True
        End If
        
        If bDurSpellApplied Then
            Call AddToCombatLog("[between round] " & m_sBetweenRoundName(x) & " - duration spell applied (" & nActiveBetweenSpells_Value(x) & ")")
            GoTo duration_ticks:
        ElseIf bResisted Then
            Call AddToCombatLog("[between round] " & m_sBetweenRoundName(x) & " (RESIST)")
            GoTo duration_ticks:
        ElseIf bAttackHit Then
            Call AddToCombatLog("[between round] " & m_sBetweenRoundName(x) & " for " & Round(nDamage))
            nRoundDamage = nRoundDamage + nDamage
            m_nTotalDamage = m_nTotalDamage + nDamage
            m_nTotalDamageSpell = m_nTotalDamageSpell + nDamage
            m_nStatBetweenRound_AtkTotalDamage(x) = m_nStatBetweenRound_AtkTotalDamage(x) + nDamage
            GoTo duration_ticks:
        End If
    Next x
    
duration_ticks:

    '============================================================================
    ' ALL SPELL DURATION TICKS
    '============================================================================
    bSepShown = False
    For x = 0 To 4
        If nActiveAtkSpells_DurationLeft(x) > 0 Then
                
            nRoundDamage = nRoundDamage + nActiveAtkSpells_Value(x)
            m_nTotalDamage = m_nTotalDamage + nActiveAtkSpells_Value(x)
            m_nTotalDamageSpell = m_nTotalDamageSpell + nActiveAtkSpells_Value(x)
            m_nStatAtkTotalDamage(x) = m_nStatAtkTotalDamage(x) + nActiveAtkSpells_Value(x)
            m_nStatAtkDmgResisted(x) = m_nStatAtkDmgResisted(x) + (nActiveAtkSpells_ValueOriginal(x) - nActiveAtkSpells_Value(x))
            
            'added 2025.06.05
            m_nStatHitSpell_AtkDmgResisted(x) = m_nStatHitSpell_AtkDmgResisted(x) + (nActiveAtkSpells_ValueOriginal(x) - nActiveAtkSpells_Value(x))
            m_nStatHitSpell_AtkTotalDamage(x) = m_nStatHitSpell_AtkTotalDamage(x) + nActiveAtkSpells_Value(x)
            
            If Not bSepShown Then
                Call AddToCombatLog("")
                bSepShown = True
            End If
            
            nActiveAtkSpells_DurationLeft(x) = nActiveAtkSpells_DurationLeft(x) - 1
            
            If m_nAtkType(x) = 2 Then 'spell
                Call AddToCombatLog("[" & m_sAtkName(x) & ", attack spell tick] for " & nActiveAtkSpells_Value(x) _
                    & " -- " & nActiveAtkSpells_DurationLeft(x) & " rounds rem.")
            Else
                sHitSpellName = IIf(Len(m_sAtkHitSpellName(x)) = 0, "attack " & (x + 1), m_sAtkHitSpellName(x))
                Call AddToCombatLog("[" & sHitSpellName & ", hit spell tick] for " & nActiveAtkSpells_Value(x) _
                    & " -- " & nActiveAtkSpells_DurationLeft(x) & " rounds rem.")
            End If
            
            If nActiveAtkSpells_Ticks(x) >= 3 Then
                nActiveAtkSpells_Ticks(x) = 1
            Else
                nActiveAtkSpells_Ticks(x) = nActiveAtkSpells_Ticks(x) + 1
            End If
            
            If nActiveAtkSpells_DurationLeft(x) < 1 Then Call ResetActiveAtkSpell(x)
        End If
        
        If nActiveBetweenSpells_DurationLeft(x) > 0 Then
                
            nRoundDamage = nRoundDamage + nActiveBetweenSpells_Value(x)
            m_nTotalDamage = m_nTotalDamage + nActiveBetweenSpells_Value(x)
            m_nTotalDamageSpell = m_nTotalDamageSpell + nActiveBetweenSpells_Value(x)
            
            'added 2025.06.05
            m_nStatBetweenRound_AtkDmgResisted(x) = m_nStatBetweenRound_AtkDmgResisted(x) + (nActiveBetweenSpells_ValueOriginal(x) - nActiveBetweenSpells_Value(x))
            m_nStatBetweenRound_AtkTotalDamage(x) = m_nStatBetweenRound_AtkTotalDamage(x) + nActiveBetweenSpells_Value(x)
            
            If Not bSepShown Then
                Call AddToCombatLog("")
                bSepShown = True
            End If
            
            nActiveBetweenSpells_DurationLeft(x) = nActiveBetweenSpells_DurationLeft(x) - 1
            
            Call AddToCombatLog("[" & m_sBetweenRoundName(x) & ", between spell tick] for " & nActiveBetweenSpells_Value(x) _
                & " -- " & nActiveBetweenSpells_DurationLeft(x) & " rounds rem.")
            
            If nActiveBetweenSpells_Ticks(x) >= 3 Then
                nActiveBetweenSpells_Ticks(x) = 1
            Else
                nActiveBetweenSpells_Ticks(x) = nActiveBetweenSpells_Ticks(x) + 1
            End If
            
            If nActiveBetweenSpells_DurationLeft(x) < 1 Then Call ResetActiveBetweenSpell(x)
        End If
    Next x
    
    Call AddToCombatLog("")
    Call AddToCombatLog("Damage for round: " & nRoundDamage, "Energy Remaining: " & nRemainingEnergy)
    Call AddToCombatLog("==================================================================")
    nCombatLogRoundCount = nCombatLogRoundCount + 1
    
    If nRoundDamage > m_nMaxRoundDamage Then
        
        m_nMaxRoundDamage = nRoundDamage
        If m_bCombatLogMaxRoundOnly Then sMaxRoundCombatLog = m_sCombatLog
        
    ElseIf m_bCombatLogMaxRoundOnly Then
        
        m_sCombatLog = ""
        nCombatLogRoundCount = 0
    
    End If
    
    If nDynamicRoundCount > 1000 And m_bDynamicCalc Then
        If nCurrentAverageDamage = 0 Then
            nCurrentAverageDamage = Round(m_nTotalDamage / nRound, 3)
            If nCurrentAverageDamage < 1 Then
                m_nNumberOfRounds = nRound
                GoTo end_sim:
            End If
            nDynamicRoundCount = 0
        Else
            nDifference = Abs(1 - (Round(m_nTotalDamage / nRound, 3) / nCurrentAverageDamage))
            If nDifference < nDynamicCalcDifference Then
                m_nNumberOfRounds = nRound
                GoTo end_sim:
            Else
                nCurrentAverageDamage = Round(m_nTotalDamage / nRound, 3)
                nDynamicRoundCount = 0
            End If
        End If
    End If
    nDynamicRoundCount = nDynamicRoundCount + 1
    
    Call ProgressBarIncrease
    If Not m_bUseCPU Then DoEvents
    
Next nRound

end_sim:
If nRound > 0 Then
    m_nAverageDamage = Round(m_nTotalDamage / nRound, 1)
    m_nAverageDamagePhys = Round(m_nTotalDamagePhys / nRound, 1)
    m_nAverageDamageSpell = Round(m_nTotalDamageSpell / nRound, 1)
End If

If m_bCombatLogMaxRoundOnly Then m_sCombatLog = sMaxRoundCombatLog

out:
On Error Resume Next
Exit Sub
error:
Call privHandleError("RunSim")
Resume out:
End Sub

Private Sub ResetActiveAtkSpell(ByVal nAttack As Integer)
On Error GoTo error:

nActiveAtkSpells_DurationLeft(nAttack) = 0
nActiveAtkSpells_Ticks(nAttack) = 0
nActiveAtkSpells_Value(nAttack) = 0

out:
On Error Resume Next
Exit Sub
error:
Call HandleError("ResetActiveAtkSpell")
Resume out:
End Sub

Private Sub ResetActiveBetweenSpell(ByVal nAttack As Integer)
On Error GoTo error:

nActiveBetweenSpells_DurationLeft(nAttack) = 0
nActiveBetweenSpells_Ticks(nAttack) = 0
nActiveBetweenSpells_Value(nAttack) = 0

out:
On Error Resume Next
Exit Sub
error:
Call HandleError("ResetActiveBetweenSpell")
Resume out:
End Sub

Public Function IsSpellResisted(ByVal nAttackResistType As Integer, ByVal nMR As Integer, ByVal nAntiMagic As Integer) As Boolean
Dim nRoll_ResistChance As Integer
On Error GoTo error:

IsSpellResisted = False

If (nAttackResistType = 1 And nAntiMagic = 1) Or nAttackResistType = 2 Then
    'if( TYPEofRESIST=Never , 0 , IF( ANTI_MAGIC=Yes or TYPEofRESIST=Yes , IF( MR>196 , 0.98 , MR/200 ) , 0 ) )
    nRoll_ResistChance = Me.RandomNumber(1, 100)
    If nMR > 196 Then nMR = 196
    If nRoll_ResistChance <= nMR / 2 Then
        IsSpellResisted = True
    End If
End If

out:
On Error Resume Next
Exit Function
error:
Call privHandleError("IsSpellResisted")
Resume out:
End Function

Public Function CalcResistedDamage(ByVal nDamage As Currency, ByVal nMR As Integer, ByVal nAntiMagic As Integer) As Currency
Dim nPercentReduction As Currency
On Error GoTo error:

If nMR > 150 Then nMR = 150

If nAntiMagic = 0 Then
    'DAMAGE = DAMAGE - ( DAMAGE * IF( MR<50, (MR-50)/100, IF( MR>150, 0.5, (MR-50)/200 ) ) )
    If nMR < 50 Then
        nPercentReduction = Round((nMR - 50) / 100, 2)
    Else
        nPercentReduction = Round((nMR - 50) / 200, 2)
    End If
Else
    'DAMAGE = DAMAGE - ( DAMAGE * IF( MR>150 , 0.75 , MR/200 ) )
    nPercentReduction = Round(nMR / 200, 2)
End If

CalcResistedDamage = nDamage - (nDamage * nPercentReduction)

out:
On Error Resume Next
Exit Function
error:
Call privHandleError("CalcResistedDamage")
Resume out:
End Function

Public Property Set cProgressBar(ByVal vData As ProgressBar)
    Set m_cProgressBar = vData
End Property

Public Property Get cProgressBar() As ProgressBar
    Set cProgressBar = m_cProgressBar
End Property

Private Sub ProgressBarSetRange(ByVal MaxValue As Double)
Dim nNewMax As Long
On Error GoTo error:

If m_cProgressBar Is Nothing Then Exit Sub

nProgressBarScale = 0

If MaxValue > MaxInt Then
    nNewMax = MaxValue
    Do While nNewMax > MaxInt
        nProgressBarScale = nProgressBarScale + 2
        If MaxValue / nProgressBarScale < MaxInt Then
            nNewMax = MaxValue / nProgressBarScale
            GoTo done:
        End If
    Loop
Else
    nNewMax = MaxValue
End If

done:
nNewMax = Fix(nNewMax)

nProgressBarScaleCount = 1
m_cProgressBar.Value = 0
m_cProgressBar.Min = 0
m_cProgressBar.Max = nNewMax

out:
On Error Resume Next
Exit Sub
error:
Call privHandleError("ProgressBarSetRange")
Resume out:
End Sub

Private Sub ProgressBarIncrease()
On Error GoTo error:

If m_cProgressBar Is Nothing Then Exit Sub

If nProgressBarScale > 0 Then
    If nProgressBarScaleCount = nProgressBarScale Then
        If m_cProgressBar.Value + 1 < m_cProgressBar.Max Then m_cProgressBar.Value = m_cProgressBar.Value + 1
        nProgressBarScaleCount = 1
    Else
        nProgressBarScaleCount = nProgressBarScaleCount + 1
    End If
Else
    If m_cProgressBar.Value + 1 < m_cProgressBar.Max Then m_cProgressBar.Value = m_cProgressBar.Value + 1
End If

out:
On Error Resume Next
Exit Sub
error:
Call privHandleError("ProgressBarIncrease")
Resume out:
End Sub

Public Sub ResetValues()
Dim x As Integer
On Error GoTo error:

m_HIT_MIN = 8
m_HIT_CAP = 99
m_SPELL_HIT_CAP = 98
m_DODGE_CAP = 95
m_DODGE_SOFTCAP = 0

m_nUserAC = 0
m_nUserDR = 0
m_nUserDodge = 0
m_nUserMR = 0
m_nUserAntiMagic = 0
m_bDodgeBeforeAC = False

m_nUserRFIR = 0
m_nUserRCOL = 0
m_nUserRLIT = 0
m_nUserRWAT = 0
m_nUserRSTO = 0

m_nEnergyPerRound = 0
m_nNumberOfRounds = 0
m_nTotalAttacks = 0
m_nTotalDamage = 0
m_nMaxRoundDamage = 0
m_nMaxEnergyPerRound = 0
m_nAverageDamage = 0

m_sCombatLog = ""
nCombatLogRoundCount = 0

For x = 0 To 4
    m_sAtkName(x) = ""
    m_nAtkType(x) = 0
    m_nAtkEnergy(x) = 0
    m_nAtkSpellType(x) = 4
    m_nAtkMin(x) = 0
    m_nAtkMax(x) = 0
    m_nAtkChance(x) = 0
    m_nAtkSuccess(x) = 0
    m_nAtkHitSpellMin(x) = 0
    m_nAtkHitSpellMax(x) = 0
    m_nAtkHitSpellType(x) = 4
    m_nAtkResist(x) = 0
    m_nAtkMRdmgResist(x) = 0
    
    m_nStatAtkAttempted(x) = 0
    m_nStatAtkHits(x) = 0
    m_nStatAtkDmgResisted(x) = 0
    m_nStatAtkAttemptDodgedOrResisted(x) = 0
    m_nStatAtkTotalDamage(x) = 0
    m_nStatHitSpell_AtkDmgResisted(x) = 0
    m_nStatHitSpell_AtkTotalDamage(x) = 0
    m_nStatBetweenRound_AtkDmgResisted(x) = 0
    m_nStatBetweenRound_AtkTotalDamage(x) = 0
    
    m_sBetweenRoundName(x) = ""
    m_nBetweenRoundMin(x) = 0
    m_nBetweenRoundMax(x) = 0
    m_nBetweenRoundSpellType(x) = 4
    m_nBetweenRoundChance(x) = 0
    m_nBetweenRoundResistType(x) = 0
    m_nBetweenRoundResistDmgMR(x) = 0
Next x

Call ResetActiveSpells

out:
On Error Resume Next
Exit Sub
error:
Call privHandleError("ResetAttacks")
Resume out:
End Sub

Private Sub ResetActiveSpells()
Dim x As Integer
On Error GoTo error:

For x = 0 To 4
    nActiveAtkSpells_Ticks(x) = 0
    nActiveAtkSpells_DurationLeft(x) = 0
    nActiveAtkSpells_Value(x) = 0
    nActiveAtkSpells_ValueOriginal(x) = 0
    
    nActiveBetweenSpells_Ticks(x) = 0
    nActiveBetweenSpells_DurationLeft(x) = 0
    nActiveBetweenSpells_Value(x) = 0
    nActiveBetweenSpells_ValueOriginal(x) = 0
Next x

out:
On Error Resume Next
Exit Sub
error:
Call HandleError("ResetActiveSpells")
Resume out:
End Sub

Private Sub privHandleError(Optional ByVal sSource As String)

If Not sSource = "" Then
    sSource = "Error " & Err.Number & " in [" & sSource & "]:" & vbCrLf
Else
    sSource = "Error " & Err.Number & ": "
End If

Select Case Err.Number
    Case 6: MsgBox sSource & "Overflow (One of the values entered was too large)."
    Case Else: MsgBox sSource & Err.Source & vbCrLf & Err.Description, vbExclamation
End Select

Err.clear
End Sub

Public Property Let nNumberOfRounds(ByVal vData As Long)
    m_nNumberOfRounds = vData
End Property

Public Property Get nNumberOfRounds() As Long
    nNumberOfRounds = m_nNumberOfRounds
End Property

Public Property Let nEnergyPerRound(ByVal vData As Integer)
    m_nEnergyPerRound = vData
End Property

Public Property Get nEnergyPerRound() As Integer
    nEnergyPerRound = m_nEnergyPerRound
End Property

Public Property Let nUserAntiMagic(ByVal vData As Integer)
    m_nUserAntiMagic = vData
End Property

Public Property Get nUserAntiMagic() As Integer
    nUserAntiMagic = m_nUserAntiMagic
End Property

Public Property Let nUserMR(ByVal vData As Long)
    m_nUserMR = vData
End Property

Public Property Get nUserMR() As Long
    nUserMR = m_nUserMR
End Property

Public Property Let nUserDodge(ByVal vData As Long)
    m_nUserDodge = vData
End Property

Public Property Get nUserDodge() As Long
    nUserDodge = m_nUserDodge
End Property
Public Property Let nUserRFIR(ByVal vData As Long)
    m_nUserRFIR = vData
End Property
Public Property Let nUserRCOL(ByVal vData As Long)
    m_nUserRCOL = vData
End Property
Public Property Let nUserRLIT(ByVal vData As Long)
    m_nUserRLIT = vData
End Property
Public Property Let nUserRWAT(ByVal vData As Long)
    m_nUserRWAT = vData
End Property
Public Property Let nUserRSTO(ByVal vData As Long)
    m_nUserRSTO = vData
End Property
Public Property Let nUserDR(ByVal vData As Long)
    m_nUserDR = vData
End Property
Public Property Get nUserRFIR() As Long
    nUserRFIR = m_nUserRFIR
End Property
Public Property Get nUserRCOL() As Long
    nUserRCOL = m_nUserRCOL
End Property
Public Property Get nUserRLIT() As Long
    nUserRLIT = m_nUserRLIT
End Property
Public Property Get nUserRWAT() As Long
    nUserRWAT = m_nUserRWAT
End Property
Public Property Get nUserRSTO() As Long
    nUserRSTO = m_nUserRSTO
End Property
Public Property Get nUserDR() As Long
    nUserDR = m_nUserDR
End Property

Public Property Let nUserAC(ByVal vData As Long)
    m_nUserAC = vData
End Property

Public Property Get nUserAC() As Long
    nUserAC = m_nUserAC
End Property

Public Property Get nStatBetweenRound_AtkTotalDamage(ByVal Index As Integer) As Currency
    nStatBetweenRound_AtkTotalDamage = m_nStatBetweenRound_AtkTotalDamage(Index)
End Property

Public Property Get nStatBetweenRound_AtkDmgResisted(ByVal Index As Integer) As Currency
    nStatBetweenRound_AtkDmgResisted = m_nStatBetweenRound_AtkDmgResisted(Index)
End Property

Public Property Get nStatHitSpell_AtkTotalDamage(ByVal Index As Integer) As Currency
    nStatHitSpell_AtkTotalDamage = m_nStatHitSpell_AtkTotalDamage(Index)
End Property

Public Property Get nStatHitSpell_AtkDmgResisted(ByVal Index As Integer) As Currency
    nStatHitSpell_AtkDmgResisted = m_nStatHitSpell_AtkDmgResisted(Index)
End Property

'Public Property Let nStatAtkTotalDamage(ByVal Index As Integer, ByVal vData As Currency)
'    'm_nStatAtkTotalDamage(Index) = vData
'End Property

Public Property Get nStatAtkTotalDamage(ByVal Index As Integer) As Currency
    nStatAtkTotalDamage = m_nStatAtkTotalDamage(Index)
End Property

'Public Property Let nStatAtkAttemptDodgedOrResisted(ByVal Index As Integer, ByVal vData As Currency)
'    m_nStatAtkAttemptDodgedOrResisted(Index) = vData
'End Property

Public Property Get nStatAtkAttemptDodgedOrResisted(ByVal Index As Integer) As Currency
    nStatAtkAttemptDodgedOrResisted = m_nStatAtkAttemptDodgedOrResisted(Index)
End Property

'Public Property Let nStatAtkDmgResisted(ByVal Index As Integer, ByVal vData As Currency)
'    m_nStatAtkDmgResisted(Index) = vData
'End Property

Public Property Get nStatAtkDmgResisted(ByVal Index As Integer) As Currency
    nStatAtkDmgResisted = m_nStatAtkDmgResisted(Index)
End Property

'Public Property Let nStatAtkHits(ByVal Index As Integer, ByVal vData As Currency)
'    m_nStatAtkHits(Index) = vData
'End Property

Public Property Get nStatAtkHits(ByVal Index As Integer) As Currency
    nStatAtkHits = m_nStatAtkHits(Index)
End Property

'Public Property Let nStatAtkAttempted(ByVal Index As Integer, ByVal vData As Currency)
'    m_nStatAtkAttempted(Index) = vData
'End Property

Public Property Get nStatAtkAttempted(ByVal Index As Integer) As Currency
    nStatAtkAttempted = m_nStatAtkAttempted(Index)
End Property

Public Property Let nAtkMRdmgResist(ByVal Index As Integer, ByVal vData As Integer)
    m_nAtkMRdmgResist(Index) = vData
End Property

Public Property Get nAtkMRdmgResist(ByVal Index As Integer) As Integer
    nAtkMRdmgResist = m_nAtkMRdmgResist(Index)
End Property

Public Property Let nAtkResist(ByVal Index As Integer, ByVal vData As Integer)
    m_nAtkResist(Index) = vData
End Property

Public Property Get nAtkResist(ByVal Index As Integer) As Integer
    nAtkResist = m_nAtkResist(Index)
End Property

Public Property Let nAtkHitSpellMax(ByVal Index As Integer, ByVal vData As Integer)
    m_nAtkHitSpellMax(Index) = vData
End Property

Public Property Get nAtkHitSpellMax(ByVal Index As Integer) As Integer
    nAtkHitSpellMax = m_nAtkHitSpellMax(Index)
End Property
Public Property Let nAtkHitSpellType(ByVal Index As Integer, ByVal vData As Integer)
    m_nAtkHitSpellType(Index) = vData
End Property
Public Property Get nAtkHitSpellType(ByVal Index As Integer) As Integer
    nAtkHitSpellType = m_nAtkHitSpellType(Index)
End Property
Public Property Let nAtkHitSpellMin(ByVal Index As Integer, ByVal vData As Integer)
    m_nAtkHitSpellMin(Index) = vData
End Property

Public Property Get nAtkHitSpellMin(ByVal Index As Integer) As Integer
    nAtkHitSpellMin = m_nAtkHitSpellMin(Index)
End Property

Public Property Let nAtkSuccess(ByVal Index As Integer, ByVal vData As Integer)
    m_nAtkSuccess(Index) = vData
End Property

Public Property Get nAtkSuccess(ByVal Index As Integer) As Integer
    nAtkSuccess = m_nAtkSuccess(Index)
End Property

Public Property Let nAtkChance(ByVal Index As Integer, ByVal vData As Integer)
    m_nAtkChance(Index) = vData
End Property

Public Property Get nAtkChance(ByVal Index As Integer) As Integer
    nAtkChance = m_nAtkChance(Index)
End Property

Public Property Let nAtkMax(ByVal Index As Integer, ByVal vData As Integer)
    m_nAtkMax(Index) = vData
End Property

Public Property Get nAtkMax(ByVal Index As Integer) As Integer
    nAtkMax = m_nAtkMax(Index)
End Property

Public Property Let nAtkMin(ByVal Index As Integer, ByVal vData As Integer)
    m_nAtkMin(Index) = vData
End Property

Public Property Get nAtkMin(ByVal Index As Integer) As Integer
    nAtkMin = m_nAtkMin(Index)
End Property

Public Property Let nAtkEnergy(ByVal Index As Integer, ByVal vData As Integer)
    m_nAtkEnergy(Index) = vData
End Property

Public Property Get nAtkEnergy(ByVal Index As Integer) As Integer
    nAtkEnergy = m_nAtkEnergy(Index)
End Property
Public Property Let nAtkSpellType(ByVal Index As Integer, ByVal vData As Integer)
    m_nAtkSpellType(Index) = vData
End Property
Public Property Get nAtkSpellType(ByVal Index As Integer) As Integer
    nAtkSpellType = m_nAtkSpellType(Index)
End Property
Public Property Let nAtkType(ByVal Index As Integer, ByVal vData As Integer)
    m_nAtkType(Index) = vData
End Property

Public Property Get nAtkType(ByVal Index As Integer) As Integer
    nAtkType = m_nAtkType(Index)
End Property

Public Property Let sAtkName(ByVal Index As Integer, ByVal vData As String)
    m_sAtkName(Index) = vData
End Property

Public Property Get sAtkName(ByVal Index As Integer) As String
    sAtkName = m_sAtkName(Index)
End Property

Public Property Let sAtkHitSpellName(ByVal Index As Integer, ByVal vData As String)
    m_sAtkHitSpellName(Index) = vData
End Property

Public Property Get sAtkHitSpellName(ByVal Index As Integer) As String
    sAtkHitSpellName = m_sAtkHitSpellName(Index)
End Property

Private Sub Class_Initialize()
m_nCombatLogMaxRounds = 10
m_nDynamicCalcDifference = 0.0001
m_HIT_MIN = 8
m_HIT_CAP = 99
m_SPELL_HIT_CAP = 98
m_DODGE_CAP = 95
m_DODGE_SOFTCAP = 0
Randomize
End Sub

Private Function Apply_GMUD_DiminishingReturns(ByVal nValue As Double, ByVal nScale As Double) As Double
Dim mult As Double, triNum As Double, isNeg As Boolean

If nScale <= 0# Then
    Apply_GMUD_DiminishingReturns = nValue
    Exit Function
End If

isNeg = (nValue < 0#)
If isNeg Then nValue = -nValue

mult = nValue / nScale
triNum = (Sqr(8# * mult + 1#) - 1#) / 2#

If isNeg Then
    Apply_GMUD_DiminishingReturns = -triNum * nScale
Else
    Apply_GMUD_DiminishingReturns = triNum * nScale
End If

End Function
